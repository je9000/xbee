#!/usr/local/bin/perl

use warnings;
use strict;
use lib '.';
use Device::XBee::API::Power;
use Data::Dumper;
use Data::Hexdumper qw/hexdump/;
use Device::SerialPort;
use IO::Select;
use IO::Socket::UNIX;
use Getopt::Tree;

use constant USERLAND_COM_SOCKET => '/tmp/xbee_power';

my $ui_options = [
    {
        name   => 'show',
        descr  => 'Show stuff.',
        exists => 1,
        params => [
            {
                name   => 'network',
                descr  => 'Show connected nodes.',
                exists => 1,
            },
        ],
    },
    {
        name   => 'set',
        descr  => 'Set a switch on a node.',
        params => [
            {
                name   => 'switch',
                descr  => 'Toggle a switch',
                exists => 1,
            }
        ]
    },
    {
        name   => 'get',
        descr  => 'Read a sensor or switch on a node.',
        params => [
            {
                name  => 'sensor',
                descr => 'Read a sensor',
            },
            {
                name  => 'switch',
                descr => 'Read a switch',
            }
        ],
    },
];

if ( -e USERLAND_COM_SOCKET ) {
    if ( IO::Socket::UNIX->new( Type => SOCK_STREAM, Peer => USERLAND_COM_SOCKET ) ) {
        die "Process already running!";
    }
    unlink USERLAND_COM_SOCKET;
}

my $serial_port_device_path = '/dev/ttyU0';

my $serial_port_device = Device::SerialPort->new( $serial_port_device_path ) || die $!;
$serial_port_device->baudrate( 9600 );
$serial_port_device->databits( 8 );
$serial_port_device->stopbits( 1 );
$serial_port_device->parity( 'none' );
$serial_port_device->read_char_time( 0 );        # don't wait for each character
$serial_port_device->read_const_time( 1000 );    # 1 second per unfulfilled "read" call

my $api = Device::XBee::API::Power->new( { fh => $serial_port_device, async => 1 } ) || die $!;
my $sock = IO::Socket::UNIX->new( Type => SOCK_STREAM, Local => USERLAND_COM_SOCKET, Listen => 10 ) || die $!;
my $sel = IO::Select->new( $sock, $serial_port_device->{FD} ) || die $!;

$api->discover_network();

while ( my @ready = $sel->can_read() ) {
    foreach my $r ( @ready ) {
        my $read;
        if ( $r == $sock ) {
            my $s = $sock->accept() || next;
            $sel->add( $s );
        } elsif ( $r == $serial_port_device->{FD} ) {
            $read = $api->rx();
            warn Dumper $read;
        } else {
            $read = <$r>;
            if ( !$read ) {
                $sel->remove( $r );
                close( $r );
                next;
            }
            $read = parse_command( $read );
            if ( $read ) { print $r $read; }
        }
    }
}

$Data::Dumper::Useqq = 1;

sub parse_command {
    my ( $cmd ) = @_;
    chomp $cmd;

    if ( $cmd eq 'help' ) {
        return usage( $ui_options );
    } elsif ( $cmd eq 'show network' ) {
            return Dumper( $api->known_nodes() );
        }
        return "unknown command $cmd";
    }
